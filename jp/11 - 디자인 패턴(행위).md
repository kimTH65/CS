# Design Pattern - Behavioral

<h2> Observer  </h2>
<h6> - オブジェクトの状態が変わる時、関連オブジェクトに変更された情報を伝達する
<br><br> - インスタンスが必要なときに作るのではなく、既存のインスタンスを使用 
<br><br> - 緩い結合でシステムが柔軟になり、依存性を取り除く
<br><br> - But.使いすぎると管理が大変
</h6>

<br>
<br>

<h2> State  </h2>
<h6> - オブジェクトの状態に応じて動作を異なる方法で処理する必要がある場合に使用するパターン
<br><br> - オブジェクトの状態をカプセル化し、これを参照する方法で処理 
</h6>

<br>
<br>

<h2> Chain of Responsibility </h2>
<h6> - リクエストを処理できるオブジェクトが2つ以上存在し、1つのオブジェクトが処理できない場合、次のオブジェクトに移動するパターン
<br><br> - リクエストを処理できる各オブジェクトがChainに縛られており、リクエストが解決されるまでChainに従って責任を転嫁する  
</h6>

<br>
<br>

<h2> Command   </h2>
<h6> - リクエストをオブジェクトの形でカプセル化して再利用したりキャンセルしたりできるように、リクエストに必要な情報を保存したりログに残すパターン
<br><br> - リクエストに使用される各種コマンドを抽象/具体クラスに分離して単純化 
</h6>

<br>
<br>

<h2> Interpreter   </h2>
<h6> - 言語に文法表現を定義するパターン
<br><br> - SQLや通信プロトコルのようなものを開発する際に使用
</h6>

<br>
<br>

<h2> Iterator  </h2>
<h6> - データ構造のようなアクセスの多いオブジェクトに対して同じインターフェイスを使用するパターン
<br><br> - 内部表現方法の露出もなく順次アクセス可能   
</h6>

<br>
<br>

<h2> Mediator   </h2>
<h6> - 数多くのオブジェクト間の複雑な相互作用をカプセル化してオブジェクトと定義するパターン 
<br><br> - オブジェクト間の依存性を減らし、結合度を低下させる、オブジェクト間の制御/指示の実行
</h6>

<br>
<br>

<h2> Visitor   </h2>
<h6> - 各クラスのデータ構造から処理機能を分離して別のクラスで構成するパターン 
<br><br> - 分離された処理機能は各クラスを訪問して実行
</h6>

<br>
<br>

<h2> Template Method  </h2>
<h6> - 上位クラスで骨格を定義し、下位クラスで細部処理を具体化する構造のパターン
<br><br> - 類似のサブクラスをまとめて共通の内容を上位クラスで定義
<br><br> - コード量を減らし、メンテナンスに容易
</h6>

<br>
<br>

<h2> Memento   </h2>
<h6> - 特定の時点でのオブジェクト内部の状態をオブジェクト化することで、その後の要求に応じてオブジェクトをその時点に戻すことができるパターン
<br><br> - 戻り機能の開発に主として使用
</h6>

<br>
<br>

<h2> Strategy   </h2>
<h6> - 同じ系列のアルゴリズムを個別にカプセル化して相互交換できるように定義
<br><br> - クライアントは独立して希望するアルゴリズムを選択し、使用、クライアントに影響なくアルゴリズムの変更が可能 
</h6>







