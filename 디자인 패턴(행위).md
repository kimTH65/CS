# 디자인 패턴(행위)

<h2> 옵저버 (Observer)  </h2>
<h6> - 객체의 상태가 변할 때 연관된 객체들에게 변경된 정보를 전달 
<br><br> - 인스턴스가 필요 할 때 만드는 것이 아닌 기존의 인스턴스를 사용 
<br><br> - 느슨한 결합으로 시스템이 유연해지고 의존성을 제거
<br><br> - But. 많이 사용하면 관리가 힘듬
</h6>

<br>
<br>

<h2> 상태 (State)   </h2>
<h6> - 객체의 상태에 따라 동작을 다르게 처리해야 할 때 사용하는 패턴
<br><br> - 객체 상태를 캡슐화하고 이를 참조하는 방식으로 처리
</h6>

<br>
<br>

<h2> 책임 연쇄 (Chain of Responsibility)  </h2>
<h6> - 요청을 처리할 수 있는 객체가 둘 이상 존재하여 한 객체가 처리하지 못하면 다음 객체로 넘어가는 형태의 패턴
<br><br> - 요청을 처리할 수 있는 각 객체들이 Chain으로 묶여 있어 요청이 해결될 때까지 Chain을 따라 책임이 넘어감 
</h6>

<br>
<br>

<h2> 커맨드 (Command)   </h2>
<h6> - 요청을 객체의 형태로 캡슐화하여 재이용하거나 취소할 수 있도록 요청에 필요한 정보를 저장하거나 로그에 남기는 패턴
<br><br> - 요청에 사용되는 각종 명령어를 추상/구체 클래스로 분리하여 단순화
</h6>

<br>
<br>

<h2> 인터프리터 (Interpreter)   </h2>
<h6> - 언어에 문법 표현을 정의하는 패턴
<br><br> - SQL이나 통신 프로토콜 같은 것을 개발할 때 사용
</h6>

<br>
<br>

<h2> 반복자 (Iterator)   </h2>
<h6> - 자료 구조와 같이 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴
<br><br> - 내부 표현 방법 노출 없이 순차적 접근 가능  
</h6>

<br>
<br>

<h2> 중재자 (Mediator)   </h2>
<h6> - 수많은 객체들 간의 복잡한 상호작용을 캡슐화하여 객체로 정의하는 패턴
<br><br> - 객체 사이의 의존성을 줄여 결합도를 감소시킴, 객체 간 통제/지시 수행
</h6>

<br>
<br>

<h2> 방문자 (Visitor)   </h2>
<h6> - 각 클래스들의 데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성하는 패턴
<br><br> - 분리된 처리 기능은 각 클래스를 방문하여 수행
</h6>

<br>
<br>

<h2> 템플릿 메소드 (Template Method)   </h2>
<h6> - 상위 클래스에서 골격을 정의하고, 하위 클래스에서 세부 처리를 구체화하는 구조의 패턴
<br><br> - 유사한 서브 클래스를 묶어 공통된 내용을 상위 클래스에서 정의
<br><br> - 코드 양을 줄여주며, 유지보수에 용이
</h6>

<br>
<br>

<h2> 메멘토 (Memento)   </h2>
<h6> - 특정 시점에서의 객체 내부 상태를 객체화함으로써 이후 요청에 따라 객체를 해당 시점으로 돌릴 수 있는 패턴
<br><br> - 되돌리기 기능 개발할 때 주로 사용  
</h6>

<br>
<br>

<h2> 전략 (Strategy)   </h2>
<h6> - 동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호 교환할 수 있게 정의
<br><br> - 클라이언트는 독립적으로 원하는 알고리즘을 선택하여 사용, 클라이언트에 영향 없이 알고리즘의 변경이 가능  
</h6>








